<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Garrek.org</title>

    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="/css/styles.css">
    <link rel="icon" type="image/png" href="/assets/favicon-96x96.png" sizes="96x96" />
<link rel="icon" type="image/svg+xml" href="/assets/favicon.svg" />
<link rel="shortcut icon" href="/assets/favicon.ico" />
<link rel="apple-touch-icon" sizes="180x180" href="/assets/apple-touch-icon.png" />
<link rel="manifest" href="/assets/site.webmanifest" />
<meta name="theme-color" content="#fcf5ef" media="(prefers-color-scheme: light)" />
<meta name="theme-color" content="#15252b" media="(prefers-color-scheme: dark)" />
</head>
<body class="wrapper">
<header class="main-head" id="masthead">
    <h1>
      <a href="/">Garrek Stemo</a>
    </h1>
</header>
<nav>
    <ul>
      <li><a href="/about/">About</a></li>
      <li><a href="/research/">Research</a></li>
      <li><a href="/photography/">Photography</a></li>
      <li><a href="/writing/">Writing</a></li>
      <li><a href="/sports/">Sports</a></li>
      <li><a href="/code/">Code</a></li>
    </ul>
</nav>

<main>

    <h2>Jumping over the time-to-first-plot problem in Julia</h2>
    <h6 class="dateline">Wednesday, October 26 2022<a class="permalinkanchor" title="Permalink" href="/2022/10/26/Jumping-over-the-time-to-first-plot-problem-in-Julia.html">&emsp;⚓︎</a></h6>
    
    <p>I’ve been using Julia for about a year now after moving my entire workflow
from Python.
When I sometimes revisit Python I am so glad I made the switch. No regrets whatsoever. Julia still has one pain point, 
which is time to first execution (TTFX) or time to first plot (TTFP)<sup id="fnref:fn_22021026_1"><a href="#fn:fn_22021026_1" class="footnote" rel="footnote" role="doc-noteref">1</a></sup>.
But even this “pain point” is somewhat bizarre because Julia is a compiled language. Of 
course there is going to be a compilation step that will make it slow to get going. What makes this a pain
point is the desire to have it all — “we are greedy,” <a href="https://julialang.org/blog/2012/02/why-we-created-julia/">say the founders</a> of the language.
Julia wants to be interactive and dynamic, but compiled and fast.
But the fact that it’s compiled means that when a user wants to make a simple line plot it takes two minutes to precompile the plotting library, compile the plotting functions, and finally show the plot on screen.
Only after that initial setup are all subsequent plots instant — as long as you keep your session active. There are many more talented programmers in the community than me, and one user in a <a href="https://discourse.julialang.org/t/very-slow-time-to-first-plot-2022/88968/27">recent Discourse thread</a> explained the tradeoff and the difficulty in reducing compile time:</p>

<blockquote>
  <p>A tangent: I believe it is worthwhile to discuss why this is such a phenomenally big problem in julia. Julia has two very special features other languages do not share: (1) multimethods as the fundamental principle for the entirety of the ecosystem and (2) compiled code. It is very difficult to know what code you need compiled and to not discard the vast majority of already compiled code when importing new libraries that add new methods for pre-existing functions. No one has had to deal with this problem before julia. It is being slowly dealt with. Sysimages basically carry the promise that no significant amount of new methods will be defined, hence they can cache more compiled code (this is very oversimplified borderline misleading explanation).</p>
</blockquote>

<p>That last point about sysimages is interesting. Making a sysimage in Visual Studio Code is a big workflow improvement, and I recommend all Julia users try it. It essentially compiles all the libraries from your project, and any other files you specify, and puts them into a file. I guess you could say it freezes your Julia session to use later. This is faster than precompiling each time. It’s built into the Julia extension and easy to set up. Detailed instructions are on the <a href="https://www.julia-vscode.org/docs/dev/userguide/compilesysimage/">Julia VS Code extension website</a>, but in a nutshell the steps are:</p>

<ol>
  <li>Open your project folder in VS Code with the <a href="https://code.visualstudio.com/docs/languages/julia">Julia extension installed</a> (and make sure it’s activated)</li>
  <li>Make a new folder called <code class="language-plaintext highlighter-rouge">.vscode</code></li>
  <li>Make a file called <code class="language-plaintext highlighter-rouge">JuliaSysimage.toml</code> in that folder</li>
  <li>Paste the <code class="language-plaintext highlighter-rouge">[sysimage]</code> text below this list into that file</li>
  <li>Select <code class="language-plaintext highlighter-rouge">Tasks: Run Build Task</code> and then <code class="language-plaintext highlighter-rouge">select Julia: Build custom sysimage for current environment</code></li>
  <li>Check the <code class="language-plaintext highlighter-rouge">useCustomSysimage</code> setting in the Julia extension settings in VS Code</li>
  <li>Restart the Julia REPL. (Hit the trash can button and open a new REPL session from the Command Palette)</li>
</ol>

<p>Copy and paste this into a <code class="language-plaintext highlighter-rouge">JuliaSysimage.toml</code> file:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[sysimage]
exclude=[]   # Additional packages to be exlucded in the system image
statements_files=[]  # Precompile statements files to be used, relative to the project folder
execution_files=[] # Precompile execution files to be used, relative to the project folder
</code></pre></div></div>

<p>The extension automatically uses the sysimage instead of precompiling your project. And now your project should run much faster and TTFX will be significantly sped-up. On my M1 iMac I use the powerful but compiler-heavy <a href="https://docs.makie.org/stable/">Makie</a> plotting library and I went from waiting about 2 minutes for precompilation and maybe 30 seconds for that first plot to almost no compile time, and execution in less than a second. (Other people have properly benchmarked this, I’m not going to do that here). I see similar results on my 2019 Intel Macbook Pro.</p>

<p>But here’s what really got my workflow sailing. I’m PhD student working in experimental physics. I have a lot of messy data and I need to make a ton of plots to explore that data. I have a top-level folder for my experiment.
In there I have separate folders for raw data, daily scripts, and results/plots.
Then I have a <code class="language-plaintext highlighter-rouge">src</code> folder where plotting, analysis, and file reading/writing scripts go. The files in <code class="language-plaintext highlighter-rouge">src</code> rarely change, so that means I can add them to the <code class="language-plaintext highlighter-rouge">execution_files</code> section in my <code class="language-plaintext highlighter-rouge">JuliaSysimage.toml</code> file. These scripts get compiled along with all my plotting packages into the sysimage. This makes <em>everything</em> fast.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>My Experiment Folder
|
|_.vscode
|   |_JuliaSysimage.toml
|_data
|   |_221015
|   |_221025
|   |_...
|_lab_notebook
|   |_221015.jl  # julia scripts for that experiment day
|   |_221025.jl
|_results
|   |_plots
|      |_221015
|      |   |_fig1.pdf
|      |_...
|
|_src
|   |_plotting_functions.jl
|   |_data_io.jl
|   |_lab_notebook_template.jl
|   |_analysis_functions.jl
|
|_JuliaSysimage.dylib
|_Project.toml
|_Manifest.toml
|_...
</code></pre></div></div>

<p>For the above example, I would add the files</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>execution_files=["src/plotting_functions.jl", "src/data_io.jl", "src/analysis_functions.jl"]
</code></pre></div></div>

<p>to <code class="language-plaintext highlighter-rouge">JuliaSysimage.toml</code>. As long as I don’t change these files, their functions load instantly. The functions in these files are used in my <code class="language-plaintext highlighter-rouge">lab_notebook</code> files with an <code class="language-plaintext highlighter-rouge">include()</code> statement at the top (e.g. <code class="language-plaintext highlighter-rouge">include("plotting_functions.jl")</code>). For example, I have custom plotting functions and themes that make an interactive grid of plots with toggles and settings so I can look at and compare data exactly the way I want. Recreating the sysimage a couple of times a month (or even once a week) is not a big deal compared to the time savings I get every day.</p>

<p>As an aside, I recommend everyone have some kind of setup like this where you reuse plotting and analysis functions, no matter what language you’re using. If you are editing these functions every day then either these scripts have not settled down yet or something isn’t quite right with the workflow. It is worth it to sit down and figure out what tools you need to build to smooth out day-to-day computational tasks instead of writing scripts from scratch each time you have to make a graph of some data. For the most part, the file format for my data is the same, so I only need a handful of plotting and data read/write functions. Once they’re written, that’s it. I can move on.</p>

<p>As many others have said, the time-to-first-X problem is a priority for the Julia developers. The version 1.8 update this year saw some speedups,
and I think the expectation is that this will continue in future 1.x releases. 
These improvements to the compilation stage, both in VS Code and the work being done in the language itself, have surpassed my expectations. I thought Julia would always have an initial lag and that people would have to make hacks and workarounds. This really is exciting, and there is a lot to look forward to in Julia’s future.</p>

<hr class="ref" />

<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:fn_22021026_1">
      <p>The plotting libraries generally take the longest to precompile. <a href="#fnref:fn_22021026_1" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>

    
</main>

<footer>
    <a href="/feed.xml">Site RSS feed</a>.<br>
	<p>©2021&ndash;2025 Garrek Stemo</p>
</footer>